# 借出指针

上一章中介绍了独占指针，这次我会介绍另外一种指针——借出指针（又称借出引用或引用），它在大多数Rust程序中远比独占指针常见。

如果你希望获得指向一个已存在的值的引用（而不是在堆中创建一个新的值并用一个独占指针指向它），我们必须要使用`&`符号，一个借出引用。这是可能是Rust中最为常见的一类指针。它很大程度上跟C++中的指针和引用（在向函数传递参数方面）用法相似。

我们使用`&`操作符来创建一个借出引用，使用`*`来解引用。对成员函数的自动解引用规则与独占指针相同。举例来说

```rust
fn foo() {
    let x = &3;   // 类型为 &i32
    let y = *x;   // 3, 类型为 i32
    bar(x, *x);
    bar(&y, y);
}

fn bar(z: &i32, i: i32) {
    // ...
}
```

`&`操作符并不分配内存（我们只能对已存在的值创建借出引用），一个借出引用退出作用域，它的空间也不会被释放。

借出引用不一定是唯一的，你可以创建多个指向同一个值的借出引用。

```rust
fn foo() {
    let x = 5;                // 类型为 i32
    let y = &x;               // 类型为 &i32
    let z = y;                // 类型为 &i32
    let w = y;                // 类型为 &i32
    println!("These should all 5: {} {} {}", *w, *y, *z);
}
```

与值相同，借出引用默认是不可变的。你可以用`&mut`来创建一个可变的借出引用（指向的值可变，而非引用本身可变），或者来表示一个可变的借出引用类型。可变借出引用是唯一的，也就是说只能每个值只能由一个可变借出引用指向。可以创建一个指向可变值的不可变引用，反之则不然。下面是一个例子

```rust
fn bar(x: &i32) { ... }
fn bar_mut(x: &mut i32) { ... }  // &mut i32 是一个指向可变的i32的引用

fn foo() {
    let x = 5;
    //let xr = &mut x;     // 错误 —— 无法借创建指向不可变值的可变引用
    let xr = &x;           // OK
    bar(xr);
    //bar_mut(xr);         // 错误 —— 需要一个可变引用

    let mut x = 5;
    let xr = &x;           // OK (创建指向可变值的不可变引用)
    //*xr = 4;             // 错误 —— 修改不可变引用
    //let xr = &mut x;     // 错误 —— 已有一个不可变引用，因而不能存在可变引用

    let mut x = 5;
    let xr = &mut x;       // OK （创建一个可变引用）
    *xr = 4;               // OK
    //let xr = &x;         // 错误 —— 已经有一个可变引用，不能创建一个不可变引用
    //let xr = &mut x;     // 错误 —— 只能由一个可变引用
    bar(xr);               // OK
    bar_mut(xr);           // OK
}
```

注意，一个引用的可变性与这个引用所指向值的可变性没有关系。这有点像C++中，指针的const属性与所指向数据的const属性无关。这一点与独占指针不同，独占指针的可变性与其值的可变性相同。

```rust
fn foo() {
    let mut x = 5;
    let mut y = 6;
    let xr = &mut x;
    //xr = &mut y;        // 错误 —— xr不可变

    let mut x = 5;
    let mut y = 6;
    let mut xr = &mut x;
    xr = &mut y;          // OK

    let mut x = 5;
    let mut y = 6;
    let mut xr = &x;
    xr = &y;              // OK —— 虽然xr所指向的值不可变，但xr可变
}
```

如果一个可变值被借出，那在被借出的这段时间它不可变。而一旦借出引用退出作用域，这个值又会变为可变。这与独占指针完全不同，借出指针一旦移动就无法继续使用。

```rust
fn foo() {
    let mut x = 5;            // 类型: i32
    {
        let y = &x;           // 类型: &i32
        //x = 4;              // 错误 —— x已经被借出
        println!("{}", x);    // OK —— c可读
    }
    x = 4;                    // OK -  可变借出退出作用域，x重新可变
}
```

上例中如果是一个可变借出引用也是同样的道理。总的来说在Rust中，数据仅能通过*一个*变量或指针修改，更进一步的，如果已经有一个可变借出引用，就不能创建一个不可变借出引用。这限制了我们如何使用底层的值。

```rust
fn foo() {
    let mut x = 5;            // 类型: i32
    {
        let y = &mut x;       // 类型: &mut i32
        //x = 4;              // 错误 —— x已经被借出
        //println!("{}", x);  // 错误 —— 需要借出x，而x已被可变借出
    }
    x = 4;                    // OK - y不再存在
}
```

与C++中不同，Rust不会自动地为值创建引用。如果一个函数的参数为引用，调用方必须显式的获取一个引用作为参数。不过指针类型可以自动转换为引用。

```rust
fn foo(x: &i32) { ... }

fn bar(x: i32, y: Box<i32>) {
    foo(&x);
    // foo(x);   // 错误 —— 需要一个&i32, 传入的却是 i32
    foo(y);      // Ok
    foo(&*y);    // 同样ok, 不过不是很好的风格
}
```

## `mut` 与 `const`

到这里，很有必要对比一下Rust中的`mut`和C++中的`const`。粗略的来说它们是相反的。默认情况下在Rust中值是不可变的，而可以使用`mut`标记为可变。而C++中值默认是可变的，可以用`const`来标记为不可变。更为重要且微妙的区别在于，C++中的常量性只针对对值的本次用例，而在Rust中不可变性对值的所有用例都适用：在C++中如果我有一个`const`变量，其他人可能会有一个指向它的非`const`引用，并且可能在我不知情的情况下修改它，而在Rust中如果你有一个不可变变量，你可以确定它不会被改变。

如前面所说，可变借出是唯一的，因此如果你有一个可变量，就可以保证如果你不修改它，它就不会变。更进一步，由于不可能有依赖于这个值不变性的其他实例存在，所以你可以任意的修改这个值。

## 借出与生存期

Rust的一个主要安全目标就是避免悬挂指针（指针的生存期比它指向的对象更长）。在Rust中，不可能创建一个悬挂的借出引用。只有借出引用指向的对象将会比借出引用本身的生存期长（至少相同），编译器才认为是合法的程序。换句话说引用的生存期必须比它所指向的值生存期短。

这可以通过本章的各个例子看出，由每个`{}`或函数引入的作用域都绑定到了一个生存期——当一个变量退出了作用域，它的生存期也就结束了。如果我们试图获得一个指向更短生存期值的引用，比如说一个更小的作用域，编译器就会提示错误。举个例子

```rust
fn foo() {
    let x = 5;
    let mut xr = &x;  // Ok - x和xr有相同的生存期
    {
        let y = 6;
        //xr = &y     // 错误 - xr比y的生存期更长
    }                 // y 在这里释放
}                     // x 和 xr 在这里释放
```

上面的例子中，`x`和`xr`的生存期并不相同，因为`xr`晚于`x`生成，但是它们生存期的结束更有意思，因为你不能引用一个尚未存在的值。这是Rust增加限制而变得比C++更安全的又一个例子。

## 显式生存期

在使用借出指针一阵之后，你可能会偶然发现具有显式生存期的借出引用。它的语法是`&'a T`（区别于`&T`)。为了说明它还需要介绍生存期多态性，因此我还是单开一章来详述（还有几个不太常见的指针类型要先介绍）。目前为止，只需要知道`&T`是 `&'a T`的缩写形式，其中`a`表示这个类型被声明位置所在的作用域。